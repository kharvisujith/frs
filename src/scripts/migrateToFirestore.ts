// Migration script with auto-generated IDs for all documents
// Uses unique fields to detect and skip duplicates

import { collection, writeBatch, doc, getDocs, query, where, serverTimestamp } from 'firebase/firestore';
import { db } from '../lib/firebase';
import { categories, products } from '../data/products';

/**
 * Migrate categories with auto-generated IDs
 * Checks for duplicates using slug field
 */
async function migrateCategories(): Promise<Map<string, string>> {
    console.log('üìÅ Migrating categories...');

    try {
        const categoriesRef = collection(db, 'categories');
        const categoryIdMap = new Map<string, string>();

        // Get existing categories to check for duplicates
        const existingSnapshot = await getDocs(categoriesRef);
        const existingSlugs = new Set(
            existingSnapshot.docs.map(doc => doc.data().slug)
        );

        const batch = writeBatch(db);
        let addedCount = 0;
        let skippedCount = 0;

        for (const category of categories) {
            // Skip if already exists (check by slug)
            if (existingSlugs.has(category.slug)) {
                console.log(`  ‚è≠Ô∏è  Skipping category: ${category.name} (already exists)`);

                // Find existing document ID for this slug
                const existing = existingSnapshot.docs.find(doc => doc.data().slug === category.slug);
                if (existing) {
                    categoryIdMap.set(category.slug, existing.id);
                }
                skippedCount++;
                continue;
            }

            // Auto-generate unique ID
            const docRef = doc(categoriesRef);
            const autoGeneratedId = docRef.id;

            categoryIdMap.set(category.slug, autoGeneratedId);

            batch.set(docRef, {
                name: category.name,
                slug: category.slug,
                description: category.description,
                image: category.image,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            });

            addedCount++;
        }

        if (addedCount > 0) {
            await batch.commit();
        }

        console.log(`‚úÖ Added ${addedCount} categories, skipped ${skippedCount} duplicates\n`);

        return categoryIdMap;
    } catch (error) {
        console.error('‚ùå Category migration failed:', error);
        throw error;
    }
}

/**
 * Migrate products with auto-generated IDs
 * Checks for duplicates using name + categorySlug combination
 */
async function migrateProducts(categoryIdMap: Map<string, string>): Promise<void> {
    console.log('üì¶ Migrating products...');

    try {
        const productsRef = collection(db, 'products');

        // Get existing products to check for duplicates
        const existingSnapshot = await getDocs(productsRef);
        const existingProducts = new Set(
            existingSnapshot.docs.map(doc => {
                const data = doc.data();
                return `${data.categorySlug}-${data.name}`;
            })
        );

        const batch = writeBatch(db);
        let addedCount = 0;
        let skippedCount = 0;

        for (const product of products) {
            const categorySlug = product.categorySlug || product.category?.toLowerCase().replace(/\s+/g, '-');
            const categoryId = categoryIdMap.get(categorySlug) || categorySlug;
            const categoryName = product.category || 'Uncategorized';

            // Create unique key for duplicate detection
            const uniqueKey = `${categorySlug}-${product.name}`;

            // Skip if already exists
            if (existingProducts.has(uniqueKey)) {
                skippedCount++;
                continue;
            }

            // Auto-generate unique ID
            const docRef = doc(productsRef);

            batch.set(docRef, {
                name: product.name,
                description: product.description,
                categoryId: categoryId,
                categoryName: categoryName,
                categorySlug: categorySlug,
                image: product.image,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            });

            addedCount++;
        }

        if (addedCount > 0) {
            await batch.commit();
        }

        console.log(`‚úÖ Added ${addedCount} products, skipped ${skippedCount} duplicates\n`);
    } catch (error) {
        console.error('‚ùå Product migration failed:', error);
        throw error;
    }
}

/**
 * Main migration function
 */
async function migrateToFirestore() {
    console.log('üöÄ Starting Firestore migration...\n');
    console.log('‚úÖ All documents use auto-generated IDs');
    console.log('‚úÖ Duplicate detection: skips existing items\n');

    try {
        // Step 1: Migrate categories
        const categoryIdMap = await migrateCategories();

        // Step 2: Migrate products
        await migrateProducts(categoryIdMap);

        // Success summary
        console.log('‚ú® Migration completed successfully!');
        console.log(`\nüéâ Your Firestore database is ready!`);
        console.log(`\n‚úÖ ID Strategy:`);
        console.log(`   - All documents: Auto-generated IDs`);
        console.log(`   - Duplicate detection: By slug (categories) and name+category (products)`);
        console.log(`   - Safe to run multiple times: Skips existing data`);
        console.log(`\nüîó View your data:`);
        console.log(`   https://console.firebase.google.com/project/futureresilienceservice/firestore`);

    } catch (error: any) {
        console.error('\n‚ùå Migration failed!');

        if (error.code === 'permission-denied') {
            console.error('\n‚ö†Ô∏è  Permission denied. Please check Firestore Security Rules.');
        } else if (error.code === 'unavailable') {
            console.error('\n‚ö†Ô∏è  Firestore is unavailable. Please check your internet connection.');
        } else {
            console.error('\nError details:', error.message);
        }

        throw error;
    }
}

// Run the migration
migrateToFirestore()
    .then(() => {
        console.log('\n‚úÖ Script completed. You can now close this.');
        process.exit(0);
    })
    .catch((error) => {
        console.error('\n‚ùå Script failed:', error);
        process.exit(1);
    });
